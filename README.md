# 패스트캠퍼스 개발자를 위한 SQL 튜닝 캠프 정리

## 1일차

### 1. 인덱스의 구조

> 인덱스 == 정렬

![인덱스구조](./images/인덱스구조.png)

([출처 : 구루비 위키](http://wiki.gurubee.net/pages/viewpage.action?pageId=26739921))  

> Root Node와 Branch Node에 표기된 lmc는 Left Most Child를 뜻합니다.  
(Leaf Node에는 없습니다.)  
다른 Key들은 명시적으로 자식 노드를 가리키지만, lmc는 가장 작은 값을 의미하기 때문에 **자식 노드 중, 가장 왼쪽**을 의미합니다.  
  
인덱스는 3개의 Node 타입으로 분류됩니다.  

* Root Node (혹은 Root Block)
  * 최상위 노드
  * 하위의 브랜치 Node수만큼 Row를 가지고 있음 
* Branch Node (혹은 Branch Block)
  * Root와 Leaf의 연결고리
  * 자기 하위의 Leaf Node 수 만큼의 Row를 가지고 있음
* Leaf Node (혹은 Leaf Block)
  * Key와 RowID로 구성
  * RowID : 해당 테이블 Row를 찾아가기 위한 주소정보
  * Key 순서대로 정렬되어있으며, 이전 이후의 Leaf Node Key를 갖고 있음

* 모든 IO의 기본단위가 블럭
  * 8k 로우가 한 블럭에 여러개 존재함

* 예)
  * 데이터 건수 : 10억, 블럭은 1000만건, 인덱스 블럭은 10만건
  * 1~10억의 데이터중 10을 찾는다면, 풀스캔은 1000만건, 인덱스 스캔은 2건에 해결
  * 수직적 스캔(효율화) : 5억을 찾는 경우 루트에서 트리로 계단식으로 내려가며 찾는 경우 
  * 수평적 스캔(선택로를 높이는 것) : 5억 ~ 5억10을 찾는 경우 5억을 찾고 이후 다시 루트에서 찾는게 아니라 5억에서 스캔을 이어가는 경우
  * 테이블 랜덤 IO(최소화)
  * 노드는 key + 하위 block 주소로 이루어짐
  * 범위 조회는 풀스캔이 인덱스 스캔보다 효율이 좋다.
  * 만약 2억을 찾는다고 하면, 풀스캔은 1천만을 수행하지만, 인덱스 스캔은 수직적 스캔 5, 수평적 2만, 테이블 랜덤 2억 = 2억 2만 5 횟수가 필요하다.
  * 인덱스 스캔은 수직적,수평적,테이블랜덤 **3개를 모두 합한 횟수**이다.

* data block : table

#### 인덱스의 탐색

* 수직적 탐색
  * Leaf Node의 시작점을 찾는 탐색
  * Root -> Branch -> Leaf
* 수평적 탐색
  * Leaf Node의 시작점부터 종료점까지 찾는 탐색

* 테이블 랜덤 Access
  * 

### 2. 인덱스의 기본원리

인덱스가 컬럼에 지정되어있어도 인덱스 사용이 안되거나 범위 스캔이 불가능한 경우가 있습니다.

#### 인덱스 컬럼의 좌측을 수정한 검색조건

**Bad**

```sql
select *
from 업체
where substr(업체명, 1, 2) = '대한';
```

**Good**

```sql
select * 
from 업체
where 업체명 like '대한%';
```

**Bad**

```sql
select *
from 사원
where 월급여 * 12 = 5000;
```

**Good**

```sql
select *
from 사원
where 월급여 = 50000/12;
```

**Bad**

```sql
select *
from 고객
where 계약구분||년월||일련번호 = 'C1312001';
```

**Good**

```sql
select *
from 고객
where 계약구분 = 'C' and 년월 = '1312' and 일변번호 = '001';
```

> 컬럼의 값을 수정해서 검색하기 보다는 **컬럼값 그대로** 조건을 변경해야합니다.


#### Null 검색

**Bad**

```sql
select *
from 고객
where 고객번호 is null;
```

> null은 인덱스가 걸리지 않습니다.  

#### 자동 형변환

컬럼과 조건절의 비교값 타입이 다를 경우 컬럼의 값을 비교값의 타입으로 변환시켜 비교하게 됩니다.

```sql
select *
from 고객
where 고객번호 = 100
```

> 자동 형변환이 발생할 경우 형변환 된 것에 인덱스가 걸린것이 아니기 때문에 인덱스 스캔이 안됩니다.  
만약 변환이 불가능할 경우 에러가 발생합니다.

### 오라클의 실행계획 보는법

> 동일한 위치에선 위에서 아래로 실행되며, 그룹내 계층구조에선 가장 아래부터 시작합니다.

**ex 1)**

```
1 ======  
2 ======  
3 ======  
```  

실행순서 : 1 -> 2 -> 3 

> 동일한 위치로 1,2,3이 있으므로 위에서 아래로 실행됩니다.

**ex 2)**

```
1 ======  
2  =====  
3   ====  
```  

실행순서 : 3 -> 2 -> 1 

> 1,2,3이 한그룹의 계층구조로 되어 있으므로 가장 아래부터 실행됩니다.

**ex 3)**

```
1 ======  
2  =====  
3  =====  
```  

실행순서 : 2 -> 3 -> 1 

> 1 은 2, 3을 갖고 있으니 순서상 둘 보다 뒤로 밀리며 2,3은 동등한 위치이므로 둘 중 위에 선언된 2가 실행된 뒤 3이 실행되고 마지막으로 1이 실행됩니다. 

**ex 4)**

```
1 ======  
2  =====  
3  =====  
4   ====  
5    ===
```

실행순서 : 2 -> 5 -> 4 -> 3 -> 1

> 1 아래에 2 3이 동등한 위치에 있으므로 2가 먼저 실행되고 3은 아래에 4,5가 있습니다. 4는 역시 5를 아래에 두고 있기 때문에 5 -> 4 -> 3 실행후 마지막으로 1이 실행됩니다.

### 다양한 인덱스 스캔 방식

#### 인덱스 Range 스캔

* Range란 where의 ```between 조회```, 단일 건이 아닌 조회를 얘기합니다.  
* 인덱스가 조합된 형태라면 

인덱스 : 부서코드 + 이름  

**Bad**

```sql
select *
from 사원
where 이름 = '홍길동'
```

**Good**

```sql
select *
from 사원
where 부서코드 = '개발부'
```


#### 인덱스 풀 스캔

#### 인덱스 유니크 스캔

#### 인덱스 스킵 스캔

### 오라클 DBMS 구조

